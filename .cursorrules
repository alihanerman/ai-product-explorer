CURSOR RULES (PROJECT CODING GUIDELINES)
Here is a set of coding and style guidelines for the "AI Product Explorer" project, following the principles you requested.
1. General Principles
Clean Code: Code should be readable, simple, and self-explanatory. Prioritize clarity over cleverness. Use meaningful names for variables, functions, and components.
DRY (Don't Repeat Yourself): Abstract repeated logic into reusable functions, custom hooks, or components. If you find yourself copying and pasting code, it's a sign that an abstraction is needed.
SOLID Principles:
S - Single Responsibility Principle (SRP): Each component and function should do one thing and do it well. A component for displaying a product grid should only handle the grid layout and mapping, not data fetching. Data fetching logic should be in the state store (productStore).
O - Open/Closed Principle: Components and modules should be open for extension but closed for modification. Use props like children or render props to extend component functionality without changing their source code.
L - Liskov Substitution Principle: Not as directly applicable to React components, but in principle, a child component should be substitutable for its parent component without breaking the application.
I - Interface Segregation Principle: Components should not be forced to depend on props they don't use. Keep prop interfaces lean and specific.
D - Dependency Inversion Principle: High-level components should not depend on low-level components. Both should depend on abstractions. In React, this is often achieved through custom hooks and context/stores, which provide data and logic without the UI component needing to know the implementation details.
2. File & Folder Structure
Adhere to the existing structure (src/app, src/components, src/lib).
Reusable UI components go in src/components. Primitive, style-only components (e.g., Button, Card) live in src/components/ui.
Business logic, API calls, and state management hooks/stores reside in src/lib.
All custom hooks should be placed in src/lib/hooks.
3. React & Next.js
Component Naming: Use PascalCase for all component files and function names (e.g., ProductCard.tsx).
Props: Always destructure props. Use TypeScript interfaces for prop types. Keep prop names descriptive.
Client vs. Server Components: Use "use client" directive only when necessary (for hooks like useState, useEffect, or event handlers). Keep components as Server Components by default for better performance.
Semantic HTML: Use semantic HTML5 tags (<main>, <header>, <aside>, <section>, <nav>) instead of <div> wherever appropriate to improve accessibility and SEO.
4. State Management (Zustand)
Single Source of Truth: Global state should be managed within Zustand stores. Avoid duplicating state in local component state if it's already in a store.
Store Segregation: Keep stores focused. authStore handles user authentication, while productStore handles product data, filters, and comparison logic.
Selectors: When accessing store data in components, use selectors to prevent unnecessary re-renders. Example: const products = useProductStore(state => state.products);
5. Styling (Tailwind CSS)
Utility-First: Prioritize Tailwind's utility classes over writing custom CSS. This ensures consistency and prevents style conflicts.
No Magic Numbers: Avoid arbitrary values like margin-top: 13px. Use the spacing scale defined in your Tailwind theme.
Responsive Design: Always design with mobile-first in mind. Use Tailwind's responsive prefixes (sm:, md:, lg:) to adapt layouts for different screen sizes. Do not let components overlap or break the layout on smaller screens.
Theme Variables: Use the CSS variables defined in globals.css (e.g., bg-background, text-primary) to maintain theme consistency (especially for dark/light modes).
6. TypeScript
Strict Typing: Enable strict mode in tsconfig.json and adhere to it.
Avoid any: Do not use the any type. If a type is unknown, use unknown and perform type checking. For complex API responses, define interfaces or types.
Zod for Validation: Use Zod schemas in src/lib/validations.ts for all API request/response validation and form validation. This is the single source of truth for data shapes.